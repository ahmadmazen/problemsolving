package problems.medium;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

/*
 * Given an array of integers nums sorted in ascending order, 
 * find the starting and ending position of a given target value.
 * 
 * Your algorithm's runtime complexity must be in the order of O(log n).
 * 
 * If the target is not found in the array, return [-1, -1].
 * 
 * Example 1:
 * Input: nums = [5,7,7,8,8,10], target = 8
 * Output: [3,4]
 * 
 * Example 2:
 * Input: nums = [5,7,7,8,8,10], target = 6
 * Output: [-1,-1]
 * 
 * Constraints:
 * 0 <= nums.length <= 10^5
 * -10^9 <= nums[i] <= 10^9
 * nums is a non decreasing array.
 * -10^9 <= target <= 10^9
 */
public class SearchRange {
	/*
	 * Approach One: linear scan the whole array looking for the target
	 * Algorithm:
	 * 1. starting from the first element of the array checking if the element == target
	 * 2. whenever we found the target we will break the loop as we found the first occurence(leftmost one) of the target
	 * 3. starting from the end of the array (reverse scan) looking for the target, 
	 * once we hit it we break (we found the rightmost one) the last occurence
	 * 4. return result array
	 * 
	 * Time Complexity: O(n) 
	 * this algorithm exhausts the search space, in the worst case we could end up visiting each element twice
	 * so the overall runtime is linear.
	 * Space Complexity: O(1)
	 */
	 public int[] searchRange_approach_one(int[] nums, int target) {
		 int[] targetRange = {-1, -1};
		 
		 if(nums == null || nums.length == 0) {
			 return targetRange;
		 }
		 //the first occurence of the target becomes the left boundary of the range
		 //then we break
		 for(int i = 0; i < nums.length; i++) {
			 if(nums[i] == target) {
				 targetRange[0] = i;
				 break;
			 }
		 }
		 //that means the target is not exist in the array
		 if(targetRange[0] == -1) {
			 return targetRange;
		 }
		 //start searching in a reverse way right--> left 
		 //to find the first occurence from the right->left direction
		 for(int i = nums.length - 1; i >= 0; i--) {
			 if(nums[i] == target) {
				 targetRange[1] = i;
				 break;
			 }
		 }
		 
		 return targetRange;
	 }
	 @Test
	 public void test_searchRange_approach_one() {
		
		 assertEquals(new int[] {3,4}, searchRange_approach_one(new int[] {5,7,7,8,8,10}, 8));
		 
		 assertEquals(new int[] {-1,-1}, searchRange_approach_one(new int[] {5,7,7,8,8,10}, 6));
	 }
}
