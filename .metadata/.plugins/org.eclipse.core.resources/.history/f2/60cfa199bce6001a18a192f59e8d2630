package problems.easy;

import java.util.ArrayList;
import java.util.List;

import problems.common.TreeNode;

public class ClosestBSTValue {
	List<Integer> flattenedBSTArray;

	public int closestValue(TreeNode root, double target) {
		// flattening the BST by inorder traversal, I will end up having array of
		// BST values sorted
		this.flattenedBSTArray = new ArrayList<Integer>();
		_inorderTraversal(root);
		// I may start binary searching the target
        return binarySearch(target);
	}

	private void _inorderTraversal(TreeNode root){
	        if(root == null){
	            return;
	        }
	        _inorderTraversal(root.getLeft());
	        flattenedBSTArray.add(root.getVal());
	        _inorderTraversal(root.getRight());
	        
	    }

	private int binarySearch(double target){
	        int low = 0;
	        int high = this.flattenedBSTArray.size() - 1;
	        double closest = Double.MAX_VALUE;
	        int res = -1;
	        while(low <= high){
	            int mid = low + (high - low) / 2;
	             double currentClosest = 
	                 target - this.flattenedBSTArray.get(mid).doubleValue();
	             if(currentClosest == closest) {
		            	res = this.flattenedBSTArray.get(mid);
		         }
	            if(currentClosest < closest) {
	            	closest = currentClosest;
	            	 low = mid + 1;  
	            }else {
	            	high = mid - 1;
	            }
	        }
	        return res;
	    }
	
	public static void main(String[] args) {
		TreeNode rootTest = new TreeNode(4);
		rootTest.setLeft(new TreeNode(2));
		rootTest.setRight(new TreeNode(5));
		rootTest.getRight().setLeft(new TreeNode(1));
		rootTest.getRight().setRight(new TreeNode(3));
		ClosestBSTValue c = new ClosestBSTValue();
		System.out.println(c.closestValue(rootTest, 3.714286));
	}
}
