package problems.medium;

import static org.junit.Assert.assertArrayEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.junit.jupiter.api.Test;

/*
 * Given a sorted array arr, two integers k and x, 
 * find the k closest elements to x in the array. 
 * The result should also be sorted in ascending order. 
 * If there is a tie, the smaller elements are always preferred.
 * 
 * Example 1:
 * Input: arr = [1,2,3,4,5], k = 4, x = 3
 * Output: [1,2,3,4]
 * 
 * Example 2:
 * Input: arr = [1,2,3,4,5], k = 4, x = -1
 * Output: [1,2,3,4]
 * 
 * Example 3:
 * Input: arr = [1,2,3,4,5], k = 4, x = 6
 * Output: [2, 3, 4, 5] 
 */
public class FindKClosestElements {
/*
 * the best solution for this problem I 've found so far was posted by a guy on leetcode discussion
 * on the below link
 * https://leetcode.com/problems/find-k-closest-elements/discuss/746762/Easy-to-understand-binary-search-method-beats-98
 * 
 * I will try to explain it 
 * 
 * Other approach : 
 */
	public List<Integer> findClosestElements(int[] arr, int k, int x) {
		List<Integer> res = new ArrayList<>();
		int start = 0;
		int end = arr.length - k - 1;
		while (start <= end) {
			int mid = (end - start) / 2 + start;
			if ((x - arr[mid]) > (arr[mid + k] - x)) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		for (int i = start; i < start + k; i++) {
			res.add(arr[i]);
		}
		return res;
	}
	/*
	 * easy to understand solution
	 * https://www.youtube.com/watch?v=kSxcZdpV2CA
	 * Algorithm:
	 * 1. binary search the array for the closest value to x and return its index
	 * 2. start expanding  to left and right around the closest value's index to reach the k closest elements
	 * 3. add the k elements to the result list
	 * 
	 */
	public List<Integer> findClosestElements_easy(int[] arr, int k, int x) {
		List<Integer> closestList = new ArrayList<>();
		int closest = binarySearch(arr, x);
		
		//expanding around the index of the closest value in the range of k 
		int low = closest, high = closest;
		while(high - low + 1 < k && low > 0  && high < arr.length -1) {
			
		}
		
		
		
		return closestList;
		
	}
	/*
	 * helper method binary search the closest element, return it's index
	 */
	private int binarySearch(int[] arr, int x) {
		int low = 0, high = arr.length - 1, min_diff = Integer.MAX_VALUE, closest = -1;
		while(low <= high) {
			int mid = low + (high - low) / 2;
			if(x - arr[mid] < min_diff) {
				min_diff = Math.abs(x - arr[mid]);
				closest = mid;
			}
			if(arr[mid] == x) {
				return mid;
			}
			else if(arr[mid] < x) {
				low = mid + 1;
			}else {
				high = mid - 1;
			}
		}
		return 0;
	}
	/*
	 * O(nlogn) solution 
	 * 1. using the sort helper method offered by Collections class
	 * 2. then sublist the first k elements of the result, 
	 * 3. then sort the sublist
	 * 
	 * the overall Time Complexity : O(nlogn) 
	 * Space Complexity : O(k) The in-place sorting does not consume any extra space. 
	 * However, generating a k length sublist will take some space.
	 */
	public List<Integer> findClosestElements_sort(List<Integer> arr, int k, int x) {
		//the second parameter of the sort method is taking comparator
		//which can be implemented inline using lambda expression java 8 and higher just as below
		// or by anonymous class like old way
		Collections.sort(arr, (a1, a2)-> 
		     a1 == a2 ? a1 - a2 : Math.abs(a1 - x) - Math.abs(a2 - x)); //O(nlogn)
		
		arr = arr.subList(0, k); // will cost us k space
		Collections.sort(arr); // O(nlogn)
		return arr;
	}
	
	
	
	
	public static void main(String[] args) {
		FindKClosestElements fcke = new FindKClosestElements();
		
		List<Integer> closestList = fcke.findClosestElements(new int[] {1,2,3,4,5}, 4, 3);
		System.out.println(Arrays.toString(closestList.toArray()));
		
	    closestList = fcke.findClosestElements(new int[] {1,2,3,4,5}, 4, -1);
		System.out.println(Arrays.toString(closestList.toArray()));
		
		closestList = fcke.findClosestElements(new int[] {1,2,3,4,5}, 4, 6);
		System.out.println(Arrays.toString(closestList.toArray()));
	}
	@Test
	public void test_findClosestKElements() {
		//case when the target inside the array
		List<Integer> closestList = findClosestElements(new int[] {1,2,3,4,5}, 4, 3);
		assertArrayEquals( new int[] {1,2,3,4}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
		//case when the target lower than the first element
		closestList = findClosestElements(new int[] {1,2,3,4,5}, 4, -1);
		assertArrayEquals( new int[] {1,2,3,4}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
		//case when the target bigger than the last element
		closestList = findClosestElements(new int[] {1,2,3,4,5}, 4, 6);
		assertArrayEquals( new int[] {2,3,4, 5}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
	}
	
	@Test
	public void test_findClosestKElements_sort() {
		//case when the target inside the array
		List<Integer> closestList = findClosestElements_sort(Arrays.asList(new Integer[] {1,2,3,4,5}), 4, 3);
		assertArrayEquals( new int[] {1,2,3,4}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
		//case when the target lower than the first element
		closestList = findClosestElements_sort(Arrays.asList(new Integer[] {1,2,3,4,5}), 4, -1);
		assertArrayEquals( new int[] {1,2,3,4}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
		//case when the target bigger than the last element
		closestList = findClosestElements_sort(Arrays.asList(new Integer[] {1,2,3,4,5}), 4, 6);
		assertArrayEquals( new int[] {2,3,4, 5}, 
				closestList.stream().mapToInt(elem -> elem.intValue()).toArray());
		
	}

}
