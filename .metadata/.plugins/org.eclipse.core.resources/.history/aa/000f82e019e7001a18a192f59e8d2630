package problems.easy;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Stack;

import problems.common.TreeNode;

public class ClosestBSTValue {
	List<Integer> flattenedBSTArray;

	/*
	 * approach one:
	 * flattening the BST by inorder traversal, I will end up having array of BST values sorted
	 * Find the closest to target element in that array.
	 * Time complexity: O(n) the recursion traversal will visit each node in the tree to fill the list
	 * then linear search to find the minimum
	 * Space complexity: O(n) space required to the list
	 */
	public int closestValue_approachOne(TreeNode root, double target) {
		// flattening the BST by inorder traversal, I will end up having array of
		// BST values sorted
		this.flattenedBSTArray = new ArrayList<Integer>();
		_inorderTraversal(root);
		// using java8 collections.min utility to return the value that has minimum
		// difference with the target
		// or implement the comparator interface by anonymous object
//		return Collections.min(flattenedBSTArray, new Comparator<Integer>() {
//			@Override
//			public int compare(Integer o1, Integer o2) {
//				return Double.compare(Math.abs(o1 - target), Math.abs(o2 - target));
//			}
//		});
		 return Collections.min(flattenedBSTArray, Comparator.comparingDouble(o->
		 Math.abs(target - o)));
	}

	private void _inorderTraversal(TreeNode root) {
		if (root == null) {
			return;
		}
		_inorderTraversal(root.getLeft());
		flattenedBSTArray.add(root.getVal());
		_inorderTraversal(root.getRight());

	}
	/*
	 * approach two: 
	 */
	public int closestValue_approachTwo(TreeNode root, double target) {
		Stack<TreeNode> stack = new Stack<TreeNode>();
		long pred = Long.MIN_VALUE;
		while (!stack.isEmpty()) {
			//traverse the leftmost
			while (root != null) {
				stack.push(root);
				root = root.getLeft();
			}
			root = stack.pop();
			if(root.getVal() > target && pred <= target) {
				return Math.abs(target - root.getVal()) < Math.abs(target - pred) ? root.getVal() : (int)pred;
			}
			
			pred = root.getVal();
			root = root.getRight();
			
		}
		return (int)pred;
	}
	public static void main(String[] args) {
		TreeNode rootTest = new TreeNode(4);
		rootTest.setLeft(new TreeNode(2));
		rootTest.setRight(new TreeNode(5));
		rootTest.getLeft().setLeft(new TreeNode(1));
		rootTest.getLeft().setRight(new TreeNode(3));
		ClosestBSTValue c = new ClosestBSTValue();
		System.out.println(c.closestValue_approachOne(rootTest, 3.714286));

		TreeNode rootTest1 = new TreeNode(2);
		rootTest1.setLeft(new TreeNode(1));

		System.out.println(c.closestValue_approachOne(rootTest1, 3.0));

	}
	
	
}
