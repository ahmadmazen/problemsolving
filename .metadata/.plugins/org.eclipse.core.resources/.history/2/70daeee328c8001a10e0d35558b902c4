package problems.medium;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

/*
 * problem definition : 
 * Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
 * (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
 * You are given a target value to search.
 * If found in the array return its index, otherwise return -1.
 * You may assume no duplicate exists in the array.
 * Your algorithm's runtime complexity must be in the order of O(log n).
 * Example 1:
 * Input: nums = [4,5,6,7,0,1,2], target = 0
 * Output: 4
 * Example 2:
 * Input: nums = [4,5,6,7,0,1,2], target = 3
 * Output: -1
 */
public class SearchRotatedSortedArray {
	/*
	 * This problem can be solved by one of two approaches:
	 * approach one: two passes-Binary Search
	 * first pass to d
	 */
	public int search(int[] nums, int target) {
		// always some sanity checks
		if (nums == null || nums.length == 0) {
			return -1;
		}
		//in case the array of only one element
		if(nums.length == 1 ) {
			return nums[0] == target ? 0 : -1;
		}
		//binary search the rotation index, in which the array is splitted into two subarrays
		//one is sorted, the other is not
		//e.g. nums = [4,5,6,7,0,1,2] from 4--> 7 unsorted, from 0-->2 sorted.
		
		
		return -1;

	}
	/*
	 * binary search the array to find the rotation index : index of the smallest element
	 */
	private int find_rotate_index(int[] nums) {
		int left = 0;
		int right = nums.length - 1;
		
		while(left <= right) {
			int pivot = left + ((right - left) / 2);
			if(nums[pivot] < nums[right]) {
				right = pivot - 1;
			}else if(nums[pivot] < nums[pivot - 1]) {
				return pivot;
				
			}else {
				left = pivot + 1;
			}
			
		}		
		//in case the array is found sorted return 0
		return 0;
	}
	
	public static void main(String[] args) {
		SearchRotatedSortedArray sra = new SearchRotatedSortedArray();
		
		System.out.println(sra.find_rotate_index(new int[] { 4, 5, 6, 7, 0, 1, 2 })); 
		System.out.println( sra.find_rotate_index(new int[] { 2, 4, 5, 6, 7, 0, 1 }));
	}
//	@Test
//	public void test_search() {
//	//	assertEquals(4, search(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 0));
//	//	assertEquals(-1, search(new int[] { 4, 5, 6, 7, 0, 1, 2 }, 3));
//	//	assertEquals(0, search(new int[] { 1 }, 1));
//	}
	@Test
	public void test_rotationIndex() {
		assertEquals(4, find_rotate_index(new int[] { 4, 5, 6, 7, 0, 1, 2 }));
		assertEquals(5, find_rotate_index(new int[] { 2, 4, 5, 6, 7, 0, 1 }));
	}
	
}
