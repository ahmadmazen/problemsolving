package problems.medium;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

/*
 * Given an array of integers nums sorted in ascending order, 
 * find the starting and ending position of a given target value.
 * 
 * Your algorithm's runtime complexity must be in the order of O(log n).
 * 
 * If the target is not found in the array, return [-1, -1].
 * 
 * Example 1:
 * Input: nums = [5,7,7,8,8,10], target = 8
 * Output: [3,4]
 * 
 * Example 2:
 * Input: nums = [5,7,7,8,8,10], target = 6
 * Output: [-1,-1]
 * 
 * Constraints:
 * 0 <= nums.length <= 10^5
 * -10^9 <= nums[i] <= 10^9
 * nums is a non decreasing array.
 * -10^9 <= target <= 10^9
 */
public class SearchRange {
	
	private static final int LEFT_DIRECTION = 1;
	private static final int RIGHT_DIRECTION = 2;
	
	/*
	 * Approach One: linear scan the whole array looking for the target
	 * Algorithm:
	 * 1. starting from the first element of the array checking if the element == target
	 * 2. whenever we found the target we will break the loop as we found the first occurence(leftmost one) of the target
	 * 3. starting from the end of the array (reverse scan) looking for the target, 
	 * once we hit it we break (we found the rightmost one) the last occurence
	 * 4. return result array
	 * 
	 * Time Complexity: O(n) 
	 * this algorithm exhausts the search space, in the worst case we could end up visiting each element twice
	 * so the overall runtime is linear.
	 * Space Complexity: O(1)
	 */
	
	
	 public int[] searchRange_approach_one(int[] nums, int target) {
		 int[] targetRange = {-1, -1};
		 
		 if(nums == null || nums.length == 0) {
			 return targetRange;
		 }
		 //the first occurence of the target becomes the left boundary of the range
		 //then we break
		 for(int i = 0; i < nums.length; i++) {
			 if(nums[i] == target) {
				 targetRange[0] = i;
				 break;
			 }
		 }
		 //that means the target is not exist in the array
		 if(targetRange[0] == -1) {
			 return targetRange;
		 }
		 //start searching in a reverse way right--> left 
		 //to find the first occurence from the right->left direction
		 for(int i = nums.length - 1; i >= 0; i--) {
			 if(nums[i] == target) {
				 targetRange[1] = i;
				 break;
			 }
		 }
		 
		 return targetRange;
	 }
	/*
	 * Approach Two: Binary Search the array looking for the target, 
	 * then binary search the leftmost and rightmost occurence
	 * 
	 * Algorithm: 
	 */
	 public int[] searchRange_approach_two(int[] nums, int target) {
		 int[] targetRange = new int[2];
		 
		 int left = 0, right = nums.length - 1;
		 
		 while(left <= right) {
			 int mid = left + (right - left) / 2;
			 if(nums[mid] > target) {
				 right = mid - 1;
				 
			 }else if(nums[mid] < target) {
				 left = mid + 1;
			 }else {
				 targetRange[0] = binarySearchFirstOccurent( nums, target, LEFT_DIRECTION);
				 targetRange[1] = binarySearchFirstOccurent( nums, target, RIGHT_DIRECTION);
				 return targetRange;
			 }
		 }
		 
		 
		 
		 
		 return targetRange;
	 }
	 
	 private int binarySearchFirstOccurent(int[] nums, int target, int direction) {
		 int firstIndex = -1;
		 int left = 0, right = nums.length - 1;
		
		while(left <= right) {
			int mid = left + (right - left) / 2;
			if(direction == RIGHT_DIRECTION) {
				if(nums[mid] <= target) {
					left = mid + 1;
					firstIndex = mid;
				}else{
					right = mid - 1;
				}
			}else if(direction == LEFT_DIRECTION) {
				if(nums[mid] >= target) {
					right = mid;
					firstIndex = mid;
				}else{
					left = mid + 1;
				}	
			}
		}

		return firstIndex;
	}
	 
	 
	 
	@Test
	 public void test_searchRange_approach_one() {

		assertArrayEquals(new int[] {3,4}, searchRange_approach_one(new int[] {5,7,7,8,8,10}, 8));
		 
		assertArrayEquals(new int[] {-1,-1}, searchRange_approach_one(new int[] {5,7,7,8,8,10}, 6));
	 }
	 
	 @Test
	 public void test_searchRange_approach_two() {

		assertArrayEquals(new int[] {3,4}, searchRange_approach_two(new int[] {5,7,7,8,8,10}, 8));
		 
		assertArrayEquals(new int[] {-1,-1}, searchRange_approach_two(new int[] {5,7,7,8,8,10}, 6));
	 }
}
